name: Build Installer


on:
  workflow_call:
    inputs:
      configuration:
        required: true
        type: string
        default: 'Release'
    outputs:
      installer-path:
        description: "Path to the built installer"
        value: ${{ jobs.build-installer.outputs.installer-path }}
        
  workflow_dispatch:
    inputs:
      configuration:
        description: 'Build configuration'
        required: true
        default: 'Release'
        type: choice
        options:
        - Release
        - Debug

jobs:
  build-installer:
    runs-on: windows-latest
    outputs:
      installer-path: ${{ steps.build.outputs.installer-path }}
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      - name: Setup Visual Studio devenv
        uses: seanmiddleditch/gha-setup-vsdevenv@v4

      - name: Setup NuGet
        uses: nuget/setup-nuget@v2

      - name: Restore NuGet packages
        run: nuget restore ppmeta.sln

      - name: Setup certificate for VSTO signing
        shell: pwsh
        env:
          VSTO_CERTIFICATE: ${{ secrets.VSTO_CERTIFICATE }}
          VSTO_CERT_THUMBPRINT: ${{ secrets.VSTO_CERT_THUMBPRINT }}
          VSTO_CERT_PASSWORD: ${{ secrets.VSTO_CERT_PASSWORD }}
        run: |
          # 设置证书用于VSTO签名
          if (-not $env:VSTO_CERTIFICATE) {
            Write-Host "No certificate provided, creating temporary certificate..."
            
            # 创建自签名证书
            $cert = New-SelfSignedCertificate -Subject "CN=PPMeta Build" -Type CodeSigning -KeyUsage DigitalSignature -FriendlyName "PPMeta Build Certificate" -CertStoreLocation Cert:\CurrentUser\My -HashAlgorithm SHA256
            
            # 导出证书到PFX文件
            $pwd = ConvertTo-SecureString -String "TempPassword123!" -Force -AsPlainText
            Export-PfxCertificate -Cert $cert -FilePath "ppmeta\temp_cert.pfx" -Password $pwd
            
            echo "CERT_THUMBPRINT=$($cert.Thumbprint)" >> $env:GITHUB_ENV
            echo "CERT_PASSWORD=TempPassword123!" >> $env:GITHUB_ENV
            echo "CERT_PATH=temp_cert.pfx" >> $env:GITHUB_ENV
          } else {
            Write-Host "Using provided certificate from secrets..."
            
            # 从secrets解码证书
            $certBytes = [System.Convert]::FromBase64String($env:VSTO_CERTIFICATE)
            [System.IO.File]::WriteAllBytes("ppmeta\production_cert.pfx", $certBytes)
            
            echo "CERT_THUMBPRINT=$env:VSTO_CERT_THUMBPRINT" >> $env:GITHUB_ENV
            echo "CERT_PASSWORD=$env:VSTO_CERT_PASSWORD" >> $env:GITHUB_ENV
            echo "CERT_PATH=production_cert.pfx" >> $env:GITHUB_ENV
          }

      - name: Install certificate
        shell: pwsh
        run: |
          $certPath = "ppmeta\$env:CERT_PATH"
          $password = ConvertTo-SecureString -String "$env:CERT_PASSWORD" -Force -AsPlainText
          
          # 安装证书到当前用户存储
          $cert = Import-PfxCertificate -FilePath $certPath -CertStoreLocation Cert:\CurrentUser\My -Password $password
          Write-Host "Certificate installed: $($cert.Thumbprint)"
          
          # 导出公钥证书供用户安装
          $publicCertPath = "ppmeta\PPMeta-CodeSigning-Certificate.cer"
          Export-Certificate -Cert $cert -FilePath $publicCertPath -Type CERT
          Write-Host "Public certificate exported: $publicCertPath"
          
          # 创建证书安装说明
          $isProduction = $env:VSTO_CERTIFICATE -and $env:VSTO_CERTIFICATE -ne ""
          $certType = if ($isProduction) { "生产环境" } else { "开发测试" }
          @"
          PPMeta 代码签名证书安装说明
          =====================================
          
          证书类型: $certType 证书
          
          如果您在运行PPMeta时遇到"Windows无法验证此软件的发布者"警告，
          请按照以下步骤安装我们的代码签名证书：
          
          方法1: 双击安装（推荐）
          1. 双击 PPMeta-CodeSigning-Certificate.cer 文件
          2. 点击"安装证书..."
          3. 选择"当前用户"，点击"下一步"
          4. 选择"将所有的证书都放入下列存储"
          5. 点击"浏览..."，选择"受信任的发布者"
          6. 点击"确定"，然后"下一步"，最后"完成"
          
          方法2: 使用PowerShell（管理员权限）
          1. 以管理员身份运行PowerShell
          2. 执行命令：
             Import-Certificate -FilePath "PPMeta-CodeSigning-Certificate.cer" -CertStoreLocation Cert:\LocalMachine\TrustedPublisher
          
          方法3: 使用组策略（企业环境）
          联系您的IT管理员，将此证书添加到"受信任的发布者"组策略中。
          
          注意事项：
          - 安装证书后，PPMeta软件将被Windows信任
          - 此证书仅用于验证PPMeta软件的真实性
          - 如果您不信任此证书，请不要安装
          $(if (-not $isProduction) { "- ⚠️ 这是开发测试证书，不是正式CA颁发的证书" })
          
          证书信息：
          主题: $($cert.Subject)
          指纹: $($cert.Thumbprint)
          有效期: $($cert.NotBefore.ToString('yyyy-MM-dd')) 至 $($cert.NotAfter.ToString('yyyy-MM-dd'))
          "@ | Out-File -FilePath "ppmeta\CERTIFICATE_INSTALL_GUIDE.txt" -Encoding UTF8
          
          # 更新项目文件中的证书指纹
          $projFile = "ppmeta\ppmeta.csproj"
          $content = Get-Content $projFile -Raw
          $content = $content -replace '<ManifestCertificateThumbprint>.*</ManifestCertificateThumbprint>', "<ManifestCertificateThumbprint>$($cert.Thumbprint)</ManifestCertificateThumbprint>"
          Set-Content $projFile $content

      - name: Build installer project with dependencies
        id: build
        shell: pwsh
        run: |
          $configuration = "${{ inputs.configuration }}"
          
          if (Test-Path "ppSetup\ppSetup.vdproj") {
            Write-Host "Building Visual Studio installer project with devenv..."
            Write-Host "Configuration: $configuration"
            
            # 先检查ppmeta项目的输出
            Write-Host "Checking ppmeta project output before building installer..."
            if (Test-Path "ppmeta\bin\$configuration\ppmeta.dll") {
              Write-Host "✅ ppmeta.dll found in bin\$configuration"
            }
            if (Test-Path "ppmeta\obj\$configuration\ppmeta.dll") {
              Write-Host "✅ ppmeta.dll found in obj\$configuration"
            } else {
              Write-Host "❌ ppmeta.dll NOT found in obj\$configuration"
              Write-Host "Installing directly to obj directory..."
              
              # 确保obj目录存在并复制必要文件
              New-Item -ItemType Directory -Path "ppmeta\obj\$configuration" -Force | Out-Null
              
              if (Test-Path "ppmeta\bin\$configuration\ppmeta.dll") {
                Copy-Item "ppmeta\bin\$configuration\ppmeta.dll" "ppmeta\obj\$configuration\" -Force
                Write-Host "✅ Copied ppmeta.dll to obj\$configuration"
              }
              
              if (Test-Path "ppmeta\bin\$configuration\ppmeta.dll.manifest") {
                Copy-Item "ppmeta\bin\$configuration\ppmeta.dll.manifest" "ppmeta\obj\$configuration\" -Force
                Write-Host "✅ Copied ppmeta.dll.manifest to obj\$configuration"
              }
              
              if (Test-Path "ppmeta\bin\$configuration\ppmeta.vsto") {
                Copy-Item "ppmeta\bin\$configuration\ppmeta.vsto" "ppmeta\obj\$configuration\" -Force
                Write-Host "✅ Copied ppmeta.vsto to obj\$configuration"
              }
            }
            
            Write-Host "Note: devenv will automatically build ppmeta project dependencies if needed"
            
            try {
              # 使用/build命令构建整个解决方案，指定安装程序项目
              Write-Host "Running: devenv ppmeta.sln /build $configuration /project ppSetup"
              devenv ppmeta.sln /build $configuration /project ppSetup
              
              $msiPath = "ppSetup\$configuration\ppSetup.msi"
              if (Test-Path $msiPath) {
                Write-Host "✅ Successfully built installer: $msiPath"
                $msiSize = (Get-Item $msiPath).Length
                Write-Host "   File size: $([math]::Round($msiSize/1MB, 2)) MB"
                echo "installer-path=$msiPath" >> $env:GITHUB_OUTPUT
              } else {
                Write-Host "❌ Installer was not created at expected path: $msiPath"
                Write-Host "Checking all possible output locations..."
                
                # 搜索所有可能的MSI文件位置
                $msiFiles = Get-ChildItem -Recurse -Filter "*.msi" -ErrorAction SilentlyContinue
                if ($msiFiles) {
                  Write-Host "Found MSI files:"
                  $msiFiles | ForEach-Object { Write-Host "  $($_.FullName) ($(([math]::Round($_.Length/1KB, 2))) KB)" }
                } else {
                  Write-Host "No MSI files found anywhere"
                }
                
                # 检查ppSetup目录内容
                if (Test-Path "ppSetup") {
                  Write-Host "Contents of ppSetup directory:"
                  Get-ChildItem "ppSetup" -Recurse | ForEach-Object { 
                    if ($_.PSIsContainer) {
                      Write-Host "  📁 $($_.FullName)"
                    } else {
                      Write-Host "  📄 $($_.FullName) ($(([math]::Round($_.Length/1KB, 2))) KB)"
                    }
                  }
                } else {
                  Write-Host "ppSetup directory not found"
                }
                
                throw "Installer build failed - MSI not found"
              }
            }
            catch {
              Write-Host "❌ Failed to build installer: $($_.Exception.Message)"
              Write-Host ""
              Write-Host "🔍 Diagnostic Information:"
              Write-Host "Configuration: $configuration"
              Write-Host "Working Directory: $(Get-Location)"
              
              # 检查ppmeta项目状态
              Write-Host ""
              Write-Host "📂 ppmeta project files:"
              if (Test-Path "ppmeta\bin\$configuration") {
                Write-Host "  bin\$configuration contents:"
                Get-ChildItem "ppmeta\bin\$configuration" | ForEach-Object { Write-Host "    $($_.Name)" }
              } else {
                Write-Host "  ❌ bin\$configuration directory not found"
              }
              
              if (Test-Path "ppmeta\obj\$configuration") {
                Write-Host "  obj\$configuration contents:"
                Get-ChildItem "ppmeta\obj\$configuration" | ForEach-Object { Write-Host "    $($_.Name)" }
              } else {
                Write-Host "  ❌ obj\$configuration directory not found"
              }
              
              # 检查ppSetup项目状态
              Write-Host ""
              Write-Host "📂 ppSetup project files:"
              if (Test-Path "ppSetup") {
                Get-ChildItem "ppSetup" | ForEach-Object { Write-Host "  $($_.Name)" }
              } else {
                Write-Host "  ❌ ppSetup directory not found"
              }
              
              throw
            }
          } else {
            Write-Host "❌ No installer project found at ppSetup\ppSetup.vdproj"
            Write-Host "Available files in current directory:"
            Get-ChildItem -Recurse -Filter "*.vdproj" | ForEach-Object { Write-Host "  $($_.FullName)" }
            throw "Installer project not found"
          }

      - name: Upload installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: installer-${{ inputs.configuration }}
          path: ${{ steps.build.outputs.installer-path }}
          retention-days: 30
